require 'digest/sha1'
class User < ActiveRecord::Base

  include ModelHumanClassName
  include ModelSviewMethods
  include DestroyOwnershipModelMethods
  
  # ---------------------------------------
  # The following code has been generated by role_requirement.
  # You may wish to modify it to suit your need
  has_and_belongs_to_many :taken_tests
  has_and_belongs_to_many :roles
  has_many :groups
  has_many :tests
  belongs_to :group
  belongs_to :user
  
  # has_role? simply needs to return true or false whether a user has a role or not.  
  # It may be a good idea to have "admin" roles return true always
  def has_role?(role_in_question)
    @_list ||= self.roles.collect(&:name)
    return true if @_list.include?("Administrator")
    (@_list.include?(role_in_question.to_s) )
  end
  # ---------------------------------------
  
  
  
  
  # Virtual attribute for the unencrypted password


  attr_accessor :password

  validates_presence_of     :user_id, :message => "nie może być pusty"
  validates_presence_of     :login, :message => "nie może pozostać pusty"
  validates_presence_of     :email, :message => "nie może pozostać pusty"
  validates_presence_of     :password,                   :if => :password_required?, :message => "nie może być puste"
  validates_presence_of     :password_confirmation,      :if => :password_required?
  validates_length_of       :password, :within => 4..40, :if => :password_required?, :message => "nie jest dopuszczalnej długości (4-40 znaków)"
  validates_confirmation_of :password,                   :if => :password_required?, :message => "musi się zgadzać z powtórzeniem"
  validates_length_of       :login,    :within => 3..40, :message => "nie jest dopuszczalnej długości (3-40)"
  validates_length_of       :email,    :within => 3..100, :message => "nie jest dopuszczalnej długości (3-100)"
  validates_uniqueness_of   :login, :email, :case_sensitive => false, :message => "znajduje się już w bazie danych"
  validates_numericality_of :index_nr, :message => "nie jest w postaci liczby"
  before_save :encrypt_password

  HUMAN_ATTRIBUTES = {
    :login                  => "Login",
    :email                  => "Adres e-mail",
    :password               => "Hasło",
    :index_nr               => "Nr indeksu",
    :owner_id               => "Identyfikator właściciela"
  }
  
  def self.human_attribute_name(attr)
    HUMAN_ATTRIBUTES[attr.to_sym] || super
  end


  # prevents a user from submitting a crafted form that bypasses activation
  # anything else you want your user to change should be added here.
  attr_accessible :login, :email, :password, :password_confirmation, :group_id, :name, :surname, :index_nr

  # Authenticates a user by their login name and unencrypted password.  Returns the user or nil.
  def self.authenticate(login, password)
    u = find_by_login(login) # need to get the salt
    u && u.authenticated?(password) ? u : nil
  end

  # Encrypts some data with the salt.
  def self.encrypt(password, salt)
    Digest::SHA1.hexdigest("--#{salt}--#{password}--")
  end

  # Encrypts the password with the user salt
  def encrypt(password)
    self.class.encrypt(password, salt)
  end

  def has_full_access?(item)
    if item.respond_to?('user_id')
      return (item.user_id == self.id)
    else
      return false
    end
    
  end
  
  def has_restricted_access?(item)
    if item.respond_to?('user_id')
      return !(eval("#{item.class.name}Ownership.find(:all, :conditions => {:user_id => #{self.id}, :item_id => #{item.id.to_s.delete("^0-9")}}).blank?"))
    else
      return false
    end
    
  end

  #Znajduje osoby mające prawa do użytkownika
  def self.find_users_with_rights(user)
      owners_ids = []
      owners_ids << user.user_id
      UserOwnership.find(:all, :conditions => {:item_id => user.id}).each {|ownership| owners_ids << ownership.user_id}
      return owners_ids.uniq!
  end

  def self.find_all_by_role_id(role_id=nil, order="name ASC")
    if role_id.nil?
      return nil
    else
      role = Role.find(role_id)
      ids = []
      User.find(:all).each { |item| (item.roles.include?(role)) ? (ids << item.id) : nil }
      return User.find(:all, :conditions => {:id => ids}, :order => order)
    end
  end

  def admin?
    (self.roles.include?(Role.find_by_name("Administrator"))) ? true : false
  end

  def student?
    (self.roles.include?(Role.find_by_name("Student"))) ? true : false
  end

  def teacher?
    (self.roles.include?(Role.find_by_name("Wykładowca"))) ? true : false
  end

  def authenticated?(password)
    crypted_password == encrypt(password)
  end

  def remember_token?
    remember_token_expires_at && Time.now.utc < remember_token_expires_at 
  end

  # These create and unset the fields required for remembering users between browser closes
  def remember_me
    remember_me_for 2.weeks
  end

  def remember_me_for(time)
    remember_me_until time.from_now.utc
  end

  def remember_me_until(time)
    self.remember_token_expires_at = time
    self.remember_token            = encrypt("#{email}--#{remember_token_expires_at}")
    save(false)
  end

  def forget_me
    self.remember_token_expires_at = nil
    self.remember_token            = nil
    save(false)
  end

  # Returns true if the user has just been activated.
  def recently_activated?
    @activated
  end

  protected
  # before filter
  def encrypt_password
    return if password.blank?
    self.salt = Digest::SHA1.hexdigest("--#{Time.now.to_s}--#{login}--") if new_record?
    self.crypted_password = encrypt(password)
  end
      
  def password_required?
    crypted_password.blank? || !password.blank?
  end
    
end
